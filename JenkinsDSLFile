pipeline {
    agent { label 'docker-agent' } 

    options {
        timeout(time:12)
        timestamps()
        ansiColor('xterm')
        buildDiscarder(logRotator(daysToKeepStr: '5'))
    }

    parameters {
        string(name:'GIT_URL',description:'Project Source code URL')
        string(name:'GIT_BRANCH',description:'Branch/CommitValue to deploy from')
        string(name:'ACCOUNT_NAME',description:"name of the AWS Account where it needs to deploy an APP")
        string(name:'COPILOT_APP',description:'Copilot Application Name')
        string(name:'COPILOT_ENV',description:'Copliot Environment Name')
        string(name:'COPILOT_SVC',description:'Copilot Service Name')
        booleanParam(name:'FORCE_DEPLOY',defaultValue: false,description:'Force (re)deploy copilot service')
    }

    environment{
        AWS_DEFAULT_REGION = 'eu-west-2'
        OUTPUT_FILE = 'output'
        IMAGE_FILE = 'image'
        TAGS_FILE = 'tags'
    }

    stages{
        stage("Init"){
            steps {
                script {
                    timestamps {
                        log_info = "\033[32mINFO: "
                        log_error = "\033[31mERROR: "
                        log_normal = "\033[0m"
                        error_message = "Failed to deploy service $env.COPILOT_SVC"
                    }
                }
            }
        }

        stage("Parameters Validation "){
            steps{
                script {
                    def unset_paramters = []
                    params.each{ key, value ->
                        if(value.toString().trim() == ''){ unset_paramters.add(key) }
                    }
                    if(unset_paramters.size()){
                        println("${log_error}Error:Please set missing paramters ${unset_paramters.toString()}${log_normal}")
                        error error_message
                    }
                    println("${log_info}Info: Parameters Validation Done${log_normal}")
                }
            }
        }

        stage("Clone Repository"){
            steps{
                    checkout(changelog: false, poll: false, scm: [ 
                        $class: 'GitSCM', 
                        branches: [[name: "$params.GIT_BRANCH" ]], 
                        doGenerateSubmoduleConfigurations: false, 
                        submoduleCfg: [], 
                        userRemoteConfigs: [[credentialsId:'GitHub', url: "$params.GIT_URL" ]]
                    ])
            }
        }

        
        stage("Deployment Validation"){

            environment { AWS_CREDS = credentials("${params.ACCOUNT_NAME}") }

            steps {
                script{
                    
                    def status = sh(returnStatus: true,
                                    script:'''
                                        set +x
                                        # check if app is there in account
                                        copilot app ls | grep -iq $COPILOT_APP && status=$?
                                        [ $status != 0 ] && echo "Can not find app \"${COPILOT_APP}\" in ${ACCOUNT_NAME}" > ${OUTPUT_FILE} && exit $?
                                
                                        # check if environment is there in account
                                        copilot env ls --app $COPILOT_APP --json | jq .environments[].name | grep -iq $COPILOT_ENV && status=$?
                                        [ $status != 0 ] && echo "Can not find Environment \"${COPILOT_ENV}\" in ${ACCOUNT_NAME}" > ${OUTPUT_FILE} && exit $?
                                         
                                        # check if service is there in account
                                        copilot svc ls --app $COPILOT_APP --json | jq .services[].name | grep -iq $COPILOT_SVC && status=$?
                                         [ $status != 0 ] && echo "Can not find Service \"${COPILOT_SVC}\" in ${COPILOT_APP}/${COPILOT_ENV}" > ${OUTPUT_FILE} && exit $?

                                        echo "Found  ${COPILOT_APP}/${COPILOT_ENV}/${COPILOT_SVC}" > ${OUTPUT_FILE}
                       
                                    ''')

                    def message = readFile(env.OUTPUT_FILE).trim()

                    if( status != 0 ){
                        println("${log_error}${message}${log_normal}")
                        error error_message
                    }

                    println("${log_info}${message}${log_normal}")
                }
            }
        }

        stage("Prepare Deployment"){

            environment { AWS_CREDS = credentials("${params.ACCOUNT_NAME}") }

            steps {
                script{
                    
                    def status = sh(returnStatus: true,
                        script: '''
                                    set +x
                                    grep location copilot/${COPILOT_SVC}/manifest.yml | grep -v '#' | awk -F':' '{print $2"/"$3}' | tr -d ' ' > ${IMAGE_FILE} && status=$?
                                    [ ${status} != 0 ] && echo "Failed to find the location" && cat ${IMAGE_FILE} > ${OUTPUT_FILE} && exit ${status}

                                    IFS=/ read -r DOCKER_REGISTRY REGISTRY_ACCOUNT IMAGE_NAME IMAGE_TAG<<< $(<${IMAGE_FILE})
                                    
                                    echo "${DOCKER_REGISTRY}/${REGISTRY_ACCOUNT}/${IMAGE_NAME}:${IMAGE_TAG}" > ${IMAGE_FILE}

                                    aws ecr list-images --repository-name ${REGISTRY_ACCOUNT}/${IMAGE_NAME} | jq .imageIds[].imageTag | tr -d '"' > ${TAGS_FILE} && status=$?
                                    [ ${status} != 0 ] && echo "Failed to find the location" && cat ${TAGS_FILE} > ${OUTPUT_FILE} && exit ${status}

                                    echo "Retrived Tags successfully" > ${OUTPUT_FILE}
                                ''')
                    
                    def message = readFile(env.OUTPUT_FILE).trim()

                    if( status != 0 ){
                        println("${log_error}${message}${log_normal}")
                        error error_message
                    }

                    println("${log_info}${message}${log_normal}")

                }
            }
        }

        stage("Deployment"){
            environment { AWS_CREDS = credentials("${params.ACCOUNT_NAME}") }

            steps{
                script{

                    def tags = readFile(env.TAGS_FILE).split("\n").collect { it as String }

                    env.DEPLOY_TAG = input message: 'Select Docker image Tag', ok: 'Deploy!',
                            parameters: [choice(name: 'Tag', choices: tags , description: 'Which Tag you want to deploy?')]


                    println("${log_info}Deploying ${params.COPILOT_SVC}${log_normal}")


                    def status = sh(returnStatus: true,
                                    script:'''
                                        set +x
                                        CURRENT_DOCKER_IMAGE=$(<${IMAGE_FILE})
                                        FINAL_DOCKER_IMAGE="$(echo ${CURRENT_DOCKER_IMAGE} | awk -F':' '{print $1}' | tr -d ' '):${DEPLOY_TAG}"
                                        sed -i "s|${CURRENT_DOCKER_IMAGE}|${FINAL_DOCKER_IMAGE}|g" copilot/$COPILOT_SVC/manifest.yml

                                        if [ ${FORCE_DEPLOY} == true ]
                                        then
                                            copilot deploy --name ${COPILOT_SVC} --app ${COPILOT_APP} --env ${COPILOT_ENV} --force 
                                        else
                                            copilot deploy --name ${COPILOT_SVC} --app ${COPILOT_APP} --env ${COPILOT_ENV}
                                        fi

                                        status=$?
                                    ''')

                    

                    if( status != 0 ){ error error_message }

                    println("${log_info}${params.COPILOT_SVC} Service deployed successfully${log_normal}")
                }
            }
        }

    }

}